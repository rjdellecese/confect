{"version":3,"file":"index.js","names":["Schema","Option","Effect"],"sources":["../../../src/client/index.ts"],"sourcesContent":["import {\n  useAction as useConvexAction,\n  useMutation as useConvexMutation,\n  useQuery as useConvexQuery,\n} from \"convex/react\";\nimport { Effect, Option, Schema } from \"effect\";\nimport * as Refs from \"../api/Refs\";\n\nexport const useQuery = <Query extends Refs.Ref.AnyPublicQuery>(\n  ref: Query,\n  args: Refs.Ref.Args<Query>[\"Type\"],\n): Option.Option<Refs.Ref.Returns<Query>[\"Type\"]> => {\n  const function_ = Refs.getFunction(ref);\n  const functionName = Refs.getConvexFunctionName(ref);\n\n  const encodedArgs = Schema.encodeSync(function_.args)(args);\n\n  const encodedReturnsOrUndefined = useConvexQuery(\n    functionName as any,\n    encodedArgs,\n  );\n\n  if (encodedReturnsOrUndefined === undefined) {\n    return Option.none();\n  } else {\n    return Option.some(\n      Schema.decodeSync(function_.returns)(encodedReturnsOrUndefined),\n    );\n  }\n};\n\nexport const useMutation = <Mutation extends Refs.Ref.AnyPublicMutation>(\n  ref: Mutation,\n) => {\n  const function_ = Refs.getFunction(ref);\n  const functionName = Refs.getConvexFunctionName(ref);\n  const actualMutation = useConvexMutation(functionName as any);\n\n  return (\n    args: Refs.Ref.Args<Mutation>[\"Type\"],\n  ): Effect.Effect<Refs.Ref.Returns<Mutation>[\"Type\"]> =>\n    Effect.gen(function* () {\n      const encodedArgs = yield* Schema.encode(function_.args)(args);\n\n      const actualReturns = yield* Effect.promise(() =>\n        actualMutation(encodedArgs),\n      );\n\n      return yield* Schema.decode(function_.returns)(actualReturns);\n    }).pipe(Effect.orDie);\n};\n\nexport const useAction = <Action extends Refs.Ref.AnyPublicAction>(\n  ref: Action,\n) => {\n  const function_ = Refs.getFunction(ref);\n  const functionName = Refs.getConvexFunctionName(ref);\n  const actualAction = useConvexAction(functionName as any);\n\n  return (\n    args: Refs.Ref.Args<Action>[\"Type\"],\n  ): Effect.Effect<Refs.Ref.Returns<Action>[\"Type\"]> =>\n    Effect.gen(function* () {\n      const encodedArgs = yield* Schema.encode(function_.args)(args);\n\n      const actualReturns = yield* Effect.promise(() =>\n        actualAction(encodedArgs),\n      );\n\n      return yield* Schema.decode(function_.returns)(actualReturns);\n    }).pipe(Effect.orDie);\n};\n"],"mappings":";;;;;AAQA,MAAa,YACX,KACA,SACmD;CACnD,MAAM,yCAA6B,IAAI;CAKvC,MAAM,8FAJ0C,IAAI,EAEhCA,cAAO,WAAW,UAAU,KAAK,CAAC,KAAK,CAK1D;AAED,KAAI,8BAA8B,OAChC,QAAOC,cAAO,MAAM;KAEpB,QAAOA,cAAO,KACZD,cAAO,WAAW,UAAU,QAAQ,CAAC,0BAA0B,CAChE;;AAIL,MAAa,eACX,QACG;CACH,MAAM,yCAA6B,IAAI;CAEvC,MAAM,sFAD0C,IAAI,CACS;AAE7D,SACE,SAEAE,cAAO,IAAI,aAAa;EACtB,MAAM,cAAc,OAAOF,cAAO,OAAO,UAAU,KAAK,CAAC,KAAK;EAE9D,MAAM,gBAAgB,OAAOE,cAAO,cAClC,eAAe,YAAY,CAC5B;AAED,SAAO,OAAOF,cAAO,OAAO,UAAU,QAAQ,CAAC,cAAc;GAC7D,CAAC,KAAKE,cAAO,MAAM;;AAGzB,MAAa,aACX,QACG;CACH,MAAM,yCAA6B,IAAI;CAEvC,MAAM,kFAD0C,IAAI,CACK;AAEzD,SACE,SAEAA,cAAO,IAAI,aAAa;EACtB,MAAM,cAAc,OAAOF,cAAO,OAAO,UAAU,KAAK,CAAC,KAAK;EAE9D,MAAM,gBAAgB,OAAOE,cAAO,cAClC,aAAa,YAAY,CAC1B;AAED,SAAO,OAAOF,cAAO,OAAO,UAAU,QAAQ,CAAC,cAAc;GAC7D,CAAC,KAAKE,cAAO,MAAM"}