{"version":3,"file":"SchemaToValidator.js","names":["Schema","Match","Array","Effect","v","Option","tableName","Predicate","SchemaAST","String","Number","effect","Exit","Cause","Data"],"sources":["../../../src/server/SchemaToValidator.ts"],"sourcesContent":["import type {\n  OptionalProperty,\n  PropertyValidators,\n  Validator,\n  VAny,\n  VArray,\n  VBoolean,\n  VBytes,\n  VFloat64,\n  VId,\n  VInt64,\n  VLiteral,\n  VNull,\n  VObject,\n  VOptional,\n  VRecord,\n  VString,\n  VUnion,\n} from \"convex/values\";\nimport { v } from \"convex/values\";\nimport {\n  Array,\n  Cause,\n  Data,\n  Effect,\n  Exit,\n  Match,\n  Number,\n  Option,\n  type ParseResult,\n  pipe,\n  Predicate,\n  Schema,\n  SchemaAST,\n  String,\n} from \"effect\";\n\nimport * as GenericId from \"../api/GenericId\";\nimport type {\n  DeepMutable,\n  IsAny,\n  IsOptional,\n  IsRecordType,\n  IsRecursive,\n  IsUnion,\n  IsValueLiteral,\n  TypeError,\n  UnionToTuple,\n} from \"../internal/typeUtils\";\n\n// Args\n\nexport const compileArgsSchema = <ConfectValue, ConvexValue>(\n  argsSchema: Schema.Schema<ConfectValue, ConvexValue>,\n): PropertyValidators => {\n  const ast = Schema.encodedSchema(argsSchema).ast;\n\n  return pipe(\n    ast,\n    Match.value,\n    Match.tag(\"TypeLiteral\", (typeLiteralAst) =>\n      Array.isEmptyReadonlyArray(typeLiteralAst.indexSignatures)\n        ? handlePropertySignatures(typeLiteralAst)\n        : Effect.fail(new IndexSignaturesAreNotSupportedError()),\n    ),\n    Match.orElse(() => Effect.fail(new TopLevelMustBeObjectError())),\n    runSyncThrow,\n  );\n};\n\n// Returns\n\nexport const compileReturnsSchema = <ConfectValue, ConvexValue>(\n  schema: Schema.Schema<ConfectValue, ConvexValue>,\n): Validator<any, any, any> =>\n  runSyncThrow(compileAst(Schema.encodedSchema(schema).ast));\n\n// Table\n\n/**\n * Convert a table `Schema` to a table `Validator`.\n */\nexport type TableSchemaToTableValidator<\n  TableSchema extends Schema.Schema.AnyNoContext,\n> =\n  ValueToValidator<TableSchema[\"Encoded\"]> extends infer Vd extends\n    | VObject<any, any, any, any>\n    | VUnion<any, any, any, any>\n    ? Vd\n    : never;\n\nexport const compileTableSchema = <\n  TableSchema extends Schema.Schema.AnyNoContext,\n>(\n  schema: TableSchema,\n): TableSchemaToTableValidator<TableSchema> => {\n  const ast = Schema.encodedSchema(schema).ast;\n\n  return pipe(\n    ast,\n    Match.value,\n    Match.tag(\"TypeLiteral\", ({ indexSignatures }) =>\n      Array.isEmptyReadonlyArray(indexSignatures)\n        ? (compileAst(ast) as Effect.Effect<any>)\n        : Effect.fail(new IndexSignaturesAreNotSupportedError()),\n    ),\n    Match.tag(\"Union\", (unionAst) => compileAst(unionAst)),\n    Match.orElse(() => Effect.fail(new TopLevelMustBeObjectOrUnionError())),\n    runSyncThrow,\n  );\n};\n\n// Compiler\n\nexport type ReadonlyValue =\n  | string\n  | number\n  | bigint\n  | boolean\n  | ArrayBuffer\n  | ReadonlyArrayValue\n  | ReadonlyRecordValue\n  | null;\n\ntype ReadonlyArrayValue = readonly ReadonlyValue[];\n\nexport type ReadonlyRecordValue = {\n  readonly [key: string]: ReadonlyValue | undefined;\n};\n\nexport type ValueToValidator<Vl> =\n  IsRecursive<Vl> extends true\n    ? VAny\n    : [Vl] extends [never]\n      ? never\n      : IsAny<Vl> extends true\n        ? VAny\n        : [Vl] extends [ReadonlyValue]\n          ? Vl extends {\n              __tableName: infer TableName extends string;\n            }\n            ? VId<GenericId.GenericId<TableName>>\n            : IsValueLiteral<Vl> extends true\n              ? VLiteral<Vl>\n              : Vl extends null\n                ? VNull\n                : Vl extends number\n                  ? VFloat64\n                  : Vl extends bigint\n                    ? VInt64\n                    : Vl extends boolean\n                      ? VBoolean\n                      : Vl extends string\n                        ? VString\n                        : Vl extends ArrayBuffer\n                          ? VBytes\n                          : Vl extends ReadonlyArray<ReadonlyValue>\n                            ? ArrayValueToValidator<Vl>\n                            : Vl extends ReadonlyRecordValue\n                              ? RecordValueToValidator<Vl>\n                              : IsUnion<Vl> extends true\n                                ? UnionValueToValidator<Vl>\n                                : TypeError<\"Unexpected value\", Vl>\n          : TypeError<\"Provided value is not a valid Convex value\", Vl>;\n\ntype ArrayValueToValidator<Vl extends ReadonlyArray<ReadonlyValue>> =\n  Vl extends ReadonlyArray<infer El extends ReadonlyValue>\n    ? ValueToValidator<El> extends infer Vd extends Validator<any, any, any>\n      ? VArray<DeepMutable<El[]>, Vd>\n      : never\n    : never;\n\ntype RecordValueToValidator<Vl> = Vl extends ReadonlyRecordValue\n  ? {\n      -readonly [K in keyof Vl]-?: IsAny<Vl[K]> extends true\n        ? IsOptional<Vl, K> extends true\n          ? VOptional<VAny>\n          : VAny\n        : UndefinedOrValueToValidator<Vl[K]>;\n    } extends infer VdRecord extends Record<string, any>\n    ? {\n        -readonly [K in keyof Vl]: DeepMutable<Vl[K]>;\n      } extends infer VlRecord extends Record<string, any>\n      ? IsRecordType<VlRecord> extends true\n        ? VRecord<VlRecord, VString, VdRecord[keyof VdRecord]>\n        : VObject<VlRecord, VdRecord>\n      : never\n    : never\n  : never;\n\nexport type UndefinedOrValueToValidator<Vl extends ReadonlyValue | undefined> =\n  undefined extends Vl\n    ? [Vl] extends [(infer Val extends ReadonlyValue) | undefined]\n      ? ValueToValidator<Val> extends infer Vd extends Validator<\n          any,\n          OptionalProperty,\n          any\n        >\n        ? VOptional<Vd>\n        : never\n      : never\n    : Vl extends ReadonlyValue\n      ? ValueToValidator<Vl>\n      : never;\n\ntype UnionValueToValidator<Vl extends ReadonlyValue> = [Vl] extends [\n  ReadonlyValue,\n]\n  ? IsUnion<Vl> extends true\n    ? UnionToTuple<Vl> extends infer VlTuple extends\n        ReadonlyArray<ReadonlyValue>\n      ? ValueTupleToValidatorTuple<VlTuple> extends infer VdTuple extends\n          Validator<any, \"required\", any>[]\n        ? VUnion<DeepMutable<Vl>, VdTuple>\n        : TypeError<\"Failed to convert value tuple to validator tuple\">\n      : TypeError<\"Failed to convert union to tuple\">\n    : TypeError<\"Expected a union of values, but got a single value instead\">\n  : TypeError<\"Provided value is not a valid Convex value\">;\n\ntype ValueTupleToValidatorTuple<VlTuple extends ReadonlyArray<ReadonlyValue>> =\n  VlTuple extends\n    | [true, false, ...infer VlRest extends ReadonlyArray<ReadonlyValue>]\n    | [false, true, ...infer VlRest extends ReadonlyArray<ReadonlyValue>]\n    ? ValueTupleToValidatorTuple<VlRest> extends infer VdRest extends Validator<\n        any,\n        any,\n        any\n      >[]\n      ? [VBoolean<boolean>, ...VdRest]\n      : never\n    : VlTuple extends [\n          infer Vl extends ReadonlyValue,\n          ...infer VlRest extends ReadonlyArray<ReadonlyValue>,\n        ]\n      ? ValueToValidator<Vl> extends infer Vd extends Validator<any, any, any>\n        ? ValueTupleToValidatorTuple<VlRest> extends infer VdRest extends\n            Validator<any, \"required\", any>[]\n          ? [Vd, ...VdRest]\n          : never\n        : never\n      : [];\n\nexport const compileSchema = <T, E>(\n  schema: Schema.Schema<T, E>,\n): ValueToValidator<(typeof schema)[\"Encoded\"]> =>\n  runSyncThrow(compileAst(schema.ast)) as any;\n\nexport const isRecursive = (ast: SchemaAST.AST): boolean =>\n  pipe(\n    ast,\n    Match.value,\n    Match.tag(\n      \"Literal\",\n      \"BooleanKeyword\",\n      \"StringKeyword\",\n      \"NumberKeyword\",\n      \"BigIntKeyword\",\n      \"UnknownKeyword\",\n      \"AnyKeyword\",\n      \"Declaration\",\n      \"UniqueSymbol\",\n      \"SymbolKeyword\",\n      \"UndefinedKeyword\",\n      \"VoidKeyword\",\n      \"NeverKeyword\",\n      \"Enums\",\n      \"TemplateLiteral\",\n      \"ObjectKeyword\",\n      \"Transformation\",\n      () => false,\n    ),\n    Match.tag(\"Union\", ({ types }) =>\n      Array.some(types, (type) => isRecursive(type)),\n    ),\n    Match.tag(\"TypeLiteral\", ({ propertySignatures }) =>\n      Array.some(propertySignatures, ({ type }) => isRecursive(type)),\n    ),\n    Match.tag(\n      \"TupleType\",\n      ({ elements: optionalElements, rest: elements }) =>\n        Array.some(optionalElements, (optionalElement) =>\n          isRecursive(optionalElement.type),\n        ) || Array.some(elements, (element) => isRecursive(element.type)),\n    ),\n    Match.tag(\"Refinement\", ({ from }) => isRecursive(from)),\n    Match.tag(\"Suspend\", () => true),\n    Match.exhaustive,\n  );\n\nexport const compileAst = (\n  ast: SchemaAST.AST,\n  isOptionalPropertyOfTypeLiteral = false,\n): Effect.Effect<\n  Validator<any, any, any>,\n  | UnsupportedSchemaTypeError\n  | UnsupportedPropertySignatureKeyTypeError\n  | IndexSignaturesAreNotSupportedError\n  | MixedIndexAndPropertySignaturesAreNotSupportedError\n  | OptionalTupleElementsAreNotSupportedError\n  | EmptyTupleIsNotSupportedError\n> =>\n  isRecursive(ast)\n    ? Effect.succeed(v.any())\n    : pipe(\n        ast,\n        Match.value,\n        Match.tag(\"Literal\", ({ literal }) =>\n          pipe(\n            literal,\n            Match.value,\n            Match.whenOr(\n              Match.string,\n              Match.number,\n              Match.bigint,\n              Match.boolean,\n              (l) => v.literal(l),\n            ),\n            Match.when(Match.null, () => v.null()),\n            Match.exhaustive,\n            Effect.succeed,\n          ),\n        ),\n        Match.tag(\"BooleanKeyword\", () => Effect.succeed(v.boolean())),\n        Match.tag(\"StringKeyword\", (stringAst) =>\n          GenericId.tableName(stringAst).pipe(\n            Option.match({\n              onNone: () => Effect.succeed(v.string()),\n              onSome: (tableName) => Effect.succeed(v.id(tableName)),\n            }),\n          ),\n        ),\n        Match.tag(\"NumberKeyword\", () => Effect.succeed(v.float64())),\n        Match.tag(\"BigIntKeyword\", () => Effect.succeed(v.int64())),\n        Match.tag(\"Union\", (unionAst) =>\n          handleUnion(unionAst, isOptionalPropertyOfTypeLiteral),\n        ),\n        Match.tag(\"TypeLiteral\", (typeLiteralAst) =>\n          handleTypeLiteral(typeLiteralAst),\n        ),\n        Match.tag(\"TupleType\", (tupleTypeAst) => handleTupleType(tupleTypeAst)),\n        Match.tag(\"UnknownKeyword\", \"AnyKeyword\", () =>\n          Effect.succeed(v.any()),\n        ),\n        Match.tag(\"Declaration\", (declaration) =>\n          Effect.mapBoth(\n            declaration.decodeUnknown(...declaration.typeParameters)(\n              new ArrayBuffer(0),\n              {},\n              declaration,\n            ) as Effect.Effect<ArrayBuffer, ParseResult.ParseIssue>,\n            {\n              onSuccess: () => v.bytes(),\n              onFailure: () =>\n                new UnsupportedSchemaTypeError({\n                  schemaType: declaration._tag,\n                }),\n            },\n          ),\n        ),\n        Match.tag(\"Refinement\", ({ from }) => compileAst(from)),\n        Match.tag(\"Suspend\", () => Effect.succeed(v.any())),\n        Match.tag(\n          \"UniqueSymbol\",\n          \"SymbolKeyword\",\n          \"UndefinedKeyword\",\n          \"VoidKeyword\",\n          \"NeverKeyword\",\n          \"Enums\",\n          \"TemplateLiteral\",\n          \"ObjectKeyword\",\n          \"Transformation\",\n          () =>\n            new UnsupportedSchemaTypeError({\n              schemaType: ast._tag,\n            }),\n        ),\n        Match.exhaustive,\n      );\n\nconst handleUnion = (\n  { types: [first, second, ...rest] }: SchemaAST.Union,\n  isOptionalPropertyOfTypeLiteral: boolean,\n) =>\n  Effect.gen(function* () {\n    const validatorEffects = isOptionalPropertyOfTypeLiteral\n      ? Array.filterMap([first, second, ...rest], (type) =>\n          Predicate.not(SchemaAST.isUndefinedKeyword)(type)\n            ? Option.some(compileAst(type))\n            : Option.none(),\n        )\n      : Array.map([first, second, ...rest], (type) => compileAst(type));\n\n    const [firstValidator, secondValidator, ...restValidators] =\n      yield* Effect.all(validatorEffects);\n\n    /* v8 ignore start */\n    if (firstValidator === undefined) {\n      return yield* Effect.dieMessage(\n        \"First validator of union is undefined; this should be impossible.\",\n      );\n      /* v8 ignore stop */\n    } else if (secondValidator === undefined) {\n      return firstValidator;\n    } else {\n      return v.union(firstValidator, secondValidator, ...restValidators);\n    }\n  });\n\nconst handleTypeLiteral = (typeLiteralAst: SchemaAST.TypeLiteral) =>\n  pipe(\n    typeLiteralAst.indexSignatures,\n    Array.head,\n    Option.match({\n      onNone: () =>\n        Effect.map(handlePropertySignatures(typeLiteralAst), v.object),\n      onSome: ({ parameter, type }) =>\n        pipe(\n          typeLiteralAst.propertySignatures,\n          Array.head,\n          Option.match({\n            onNone: () =>\n              Effect.map(\n                Effect.all({\n                  parameter_: compileAst(parameter),\n                  type_: compileAst(type),\n                }),\n                ({ parameter_, type_ }) => v.record(parameter_, type_),\n              ),\n            onSome: () =>\n              Effect.fail(\n                new MixedIndexAndPropertySignaturesAreNotSupportedError(),\n              ),\n          }),\n        ),\n    }),\n  );\n\nconst handleTupleType = ({ elements, rest }: SchemaAST.TupleType) =>\n  Effect.gen(function* () {\n    const restValidator = pipe(\n      rest,\n      Array.head,\n      Option.map(({ type }) => compileAst(type)),\n      Effect.flatten,\n    );\n\n    const [f, s, ...r] = elements;\n\n    const elementToValidator = ({ type, isOptional }: SchemaAST.OptionalType) =>\n      Effect.if(isOptional, {\n        onTrue: () =>\n          Effect.fail(new OptionalTupleElementsAreNotSupportedError()),\n        onFalse: () => compileAst(type),\n      });\n\n    const arrayItemsValidator = yield* f === undefined\n      ? pipe(\n          restValidator,\n          Effect.catchTag(\"NoSuchElementException\", () =>\n            Effect.fail(new EmptyTupleIsNotSupportedError()),\n          ),\n        )\n      : s === undefined\n        ? elementToValidator(f)\n        : Effect.gen(function* () {\n            const firstValidator = yield* elementToValidator(f);\n            const secondValidator = yield* elementToValidator(s);\n            const restValidators = yield* Effect.forEach(r, elementToValidator);\n\n            return v.union(firstValidator, secondValidator, ...restValidators);\n          });\n\n    return v.array(arrayItemsValidator);\n  });\n\nconst handlePropertySignatures = (typeLiteralAst: SchemaAST.TypeLiteral) =>\n  pipe(\n    typeLiteralAst.propertySignatures,\n    Effect.forEach(({ type, name, isOptional }) => {\n      if (String.isString(name)) {\n        // Somehow, somewhere, keys of type number are being coerced to stringsâ€¦\n        return Option.match(Number.parse(name), {\n          onNone: () =>\n            Effect.gen(function* () {\n              const validator = yield* compileAst(type, isOptional);\n\n              return {\n                propertyName: name,\n                validator: isOptional ? v.optional(validator) : validator,\n              };\n            }),\n          onSome: (number) =>\n            Effect.fail(\n              new UnsupportedPropertySignatureKeyTypeError({\n                propertyKey: number,\n              }),\n            ),\n        });\n      } else {\n        return Effect.fail(\n          new UnsupportedPropertySignatureKeyTypeError({ propertyKey: name }),\n        );\n      }\n    }),\n    Effect.andThen((propertyNamesWithValidators) =>\n      pipe(\n        propertyNamesWithValidators,\n        Array.reduce(\n          {} as Record<string, Validator<any, any, any>>,\n          (acc, { propertyName, validator }) => ({\n            [propertyName]: validator,\n            ...acc,\n          }),\n        ),\n        Effect.succeed,\n      ),\n    ),\n  );\n\n// Errors\n\nconst runSyncThrow = <A, E>(effect: Effect.Effect<A, E>) =>\n  pipe(\n    effect,\n    Effect.runSyncExit,\n    Exit.match({\n      onSuccess: (validator) => validator,\n      onFailure: (cause) => {\n        throw Cause.squash(cause);\n      },\n    }),\n  );\n\nexport class TopLevelMustBeObjectError extends Data.TaggedError(\n  \"TopLevelMustBeObjectError\",\n) {\n  /* v8 ignore start */\n  override get message() {\n    return \"Top level schema must be an object\";\n  }\n  /* v8 ignore stop */\n}\n\nexport class TopLevelMustBeObjectOrUnionError extends Data.TaggedError(\n  \"TopLevelMustBeObjectOrUnionError\",\n) {\n  /* v8 ignore start */\n  override get message() {\n    return \"Top level schema must be an object or a union\";\n  }\n  /* v8 ignore stop */\n}\n\nexport class UnsupportedPropertySignatureKeyTypeError extends Data.TaggedError(\n  \"UnsupportedPropertySignatureKeyTypeError\",\n)<{\n  readonly propertyKey: number | symbol;\n}> {\n  /* v8 ignore start */\n  override get message() {\n    return `Unsupported property signature '${this.propertyKey.toString()}'. Property is of type '${typeof this.propertyKey}' but only 'string' properties are supported.`;\n  }\n  /* v8 ignore stop */\n}\n\nexport class EmptyTupleIsNotSupportedError extends Data.TaggedError(\n  \"EmptyTupleIsNotSupportedError\",\n) {\n  /* v8 ignore start */\n  override get message() {\n    return \"Tuple must have at least one element\";\n  }\n  /* v8 ignore stop */\n}\n\nexport class UnsupportedSchemaTypeError extends Data.TaggedError(\n  \"UnsupportedSchemaTypeError\",\n)<{\n  readonly schemaType: SchemaAST.AST[\"_tag\"];\n}> {\n  /* v8 ignore start */\n  override get message() {\n    return `Unsupported schema type '${this.schemaType}'`;\n  }\n  /* v8 ignore stop */\n}\n\nexport class IndexSignaturesAreNotSupportedError extends Data.TaggedError(\n  \"IndexSignaturesAreNotSupportedError\",\n) {\n  /* v8 ignore start */\n  override get message() {\n    return \"Index signatures are not supported\";\n  }\n  /* v8 ignore stop */\n}\n\nexport class MixedIndexAndPropertySignaturesAreNotSupportedError extends Data.TaggedError(\n  \"MixedIndexAndPropertySignaturesAreNotSupportedError\",\n) {\n  /* v8 ignore start */\n  override get message() {\n    return \"Mixed index and property signatures are not supported\";\n  }\n  /* v8 ignore stop */\n}\n\nexport class OptionalTupleElementsAreNotSupportedError extends Data.TaggedError(\n  \"OptionalTupleElementsAreNotSupportedError\",\n) {\n  /* v8 ignore start */\n  override get message() {\n    return \"Optional tuple elements are not supported\";\n  }\n  /* v8 ignore stop */\n}\n"],"mappings":"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"}