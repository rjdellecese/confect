{"version":3,"file":"index.js","names":["Refs.getFunction","useConvexQuery","Refs.getConvexFunctionName","useConvexMutation","useConvexAction"],"sources":["../../../src/client/index.ts"],"sourcesContent":["import {\n  useAction as useConvexAction,\n  useMutation as useConvexMutation,\n  useQuery as useConvexQuery,\n} from \"convex/react\";\nimport { Effect, Option, Schema } from \"effect\";\nimport * as Refs from \"../api/Refs\";\n\nexport const useQuery = <Query extends Refs.Ref.AnyPublicQuery>(\n  ref: Query,\n  args: Refs.Ref.Args<Query>[\"Type\"],\n): Option.Option<Refs.Ref.Returns<Query>[\"Type\"]> => {\n  const function_ = Refs.getFunction(ref);\n  const functionName = Refs.getConvexFunctionName(ref);\n\n  const encodedArgs = Schema.encodeSync(function_.args)(args);\n\n  const encodedReturnsOrUndefined = useConvexQuery(\n    functionName as any,\n    encodedArgs,\n  );\n\n  if (encodedReturnsOrUndefined === undefined) {\n    return Option.none();\n  } else {\n    return Option.some(\n      Schema.decodeSync(function_.returns)(encodedReturnsOrUndefined),\n    );\n  }\n};\n\nexport const useMutation = <Mutation extends Refs.Ref.AnyPublicMutation>(\n  ref: Mutation,\n) => {\n  const function_ = Refs.getFunction(ref);\n  const functionName = Refs.getConvexFunctionName(ref);\n  const actualMutation = useConvexMutation(functionName as any);\n\n  return (\n    args: Refs.Ref.Args<Mutation>[\"Type\"],\n  ): Effect.Effect<Refs.Ref.Returns<Mutation>[\"Type\"]> =>\n    Effect.gen(function* () {\n      const encodedArgs = yield* Schema.encode(function_.args)(args);\n\n      const actualReturns = yield* Effect.promise(() =>\n        actualMutation(encodedArgs),\n      );\n\n      return yield* Schema.decode(function_.returns)(actualReturns);\n    }).pipe(Effect.orDie);\n};\n\nexport const useAction = <Action extends Refs.Ref.AnyPublicAction>(\n  ref: Action,\n) => {\n  const function_ = Refs.getFunction(ref);\n  const functionName = Refs.getConvexFunctionName(ref);\n  const actualAction = useConvexAction(functionName as any);\n\n  return (\n    args: Refs.Ref.Args<Action>[\"Type\"],\n  ): Effect.Effect<Refs.Ref.Returns<Action>[\"Type\"]> =>\n    Effect.gen(function* () {\n      const encodedArgs = yield* Schema.encode(function_.args)(args);\n\n      const actualReturns = yield* Effect.promise(() =>\n        actualAction(encodedArgs),\n      );\n\n      return yield* Schema.decode(function_.returns)(actualReturns);\n    }).pipe(Effect.orDie);\n};\n"],"mappings":";;;;;AAQA,MAAa,YACX,KACA,SACmD;CACnD,MAAM,YAAYA,YAAiB,IAAI;CAKvC,MAAM,4BAA4BC,WAJbC,sBAA2B,IAAI,EAEhC,OAAO,WAAW,UAAU,KAAK,CAAC,KAAK,CAK1D;AAED,KAAI,8BAA8B,OAChC,QAAO,OAAO,MAAM;KAEpB,QAAO,OAAO,KACZ,OAAO,WAAW,UAAU,QAAQ,CAAC,0BAA0B,CAChE;;AAIL,MAAa,eACX,QACG;CACH,MAAM,YAAYF,YAAiB,IAAI;CAEvC,MAAM,iBAAiBG,cADFD,sBAA2B,IAAI,CACS;AAE7D,SACE,SAEA,OAAO,IAAI,aAAa;EACtB,MAAM,cAAc,OAAO,OAAO,OAAO,UAAU,KAAK,CAAC,KAAK;EAE9D,MAAM,gBAAgB,OAAO,OAAO,cAClC,eAAe,YAAY,CAC5B;AAED,SAAO,OAAO,OAAO,OAAO,UAAU,QAAQ,CAAC,cAAc;GAC7D,CAAC,KAAK,OAAO,MAAM;;AAGzB,MAAa,aACX,QACG;CACH,MAAM,YAAYF,YAAiB,IAAI;CAEvC,MAAM,eAAeI,YADAF,sBAA2B,IAAI,CACK;AAEzD,SACE,SAEA,OAAO,IAAI,aAAa;EACtB,MAAM,cAAc,OAAO,OAAO,OAAO,UAAU,KAAK,CAAC,KAAK;EAE9D,MAAM,gBAAgB,OAAO,OAAO,cAClC,aAAa,YAAY,CAC1B;AAED,SAAO,OAAO,OAAO,OAAO,UAAU,QAAQ,CAAC,cAAc;GAC7D,CAAC,KAAK,OAAO,MAAM"}