---
icon: "octagon-minus"
title: "Schema Restrictions"
description: "Understand the restrictions on Effect schemas that can be used in Confect."
---

Not every Effect `Schema` is valid for use in Confect. Remember that an Effect `Schema` looks like this:

```typescript
type Schema<Type, Encoded, Context>
```

For `Schema`s used in Confect:

- `Type` represents the value that you'll be operating on in your code. Any TypeScript type is permitted here.
- `Encoded` represents the value that is stored in the database or serialized as the argument/output of a Convex function. This must be a valid [Convex value](https://docs.convex.dev/database/types#convex-values).
- `Context` is not currently supported. It should always be `never`.

## Additional caveats

### No-op returns from Convex functions

Unlike the vanilla APIs, Convex functions defined with Confect may not return `undefined` or `void`—use `null` (`Schema.Null` as the `returns` validator) instead. Convex coerces `undefined`/`void` returns to `null` anyways—this just makes that more explicit.

```typescript ✅
export const myQuery = query({
  args: Schema.Struct({}),
  returns: Schema.Null,
  handler: () => Effect.succeed(null),
});
```

```typescript ❌
export const myQuery = query({
  args: Schema.Struct({}),
  returns: Schema.Undefined,
  handler: () => Effect.succeed(undefined),
});
```

```typescript ❌
export const myQuery = query({
  args: Schema.Struct({}),
  returns: Schema.Void,
  handler: () => Effect.void,
});
```
