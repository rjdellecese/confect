{"version":3,"file":"QueryInitializer.js","names":["indexFields: GenericTableIndexes[keyof GenericTableIndexes]","Document.decode","get: QueryInitializerFunction<\"get\">","index: QueryInitializerFunction<\"index\">","OrderedQuery.make","search: QueryInitializerFunction<\"search\">","Document.documentErrorMessage"],"sources":["../../../src/server/QueryInitializer.ts"],"sourcesContent":["import type {\n  OrderedQuery as ConvexOrderedQuery,\n  QueryInitializer as ConvexQueryInitializer,\n  DocumentByInfo,\n  GenericTableIndexes,\n  GenericTableInfo,\n  Indexes,\n  IndexRange,\n  IndexRangeBuilder,\n  NamedIndex,\n  NamedSearchIndex,\n  NamedTableInfo,\n  Query,\n  SearchFilter,\n  SearchFilterBuilder,\n  SearchIndexes,\n} from \"convex/server\";\nimport type { GenericId } from \"convex/values\";\nimport { Array, Effect, Either, pipe, Schema } from \"effect\";\nimport type {\n  BaseDatabaseReader,\n  IndexFieldTypesForEq,\n} from \"../internal/typeUtils\";\nimport type * as DataModel from \"./DataModel\";\nimport * as Document from \"./Document\";\nimport * as OrderedQuery from \"./OrderedQuery\";\nimport type * as Table from \"./Table\";\nimport type * as TableInfo from \"./TableInfo\";\n\ntype QueryInitializer<\n  DataModel_ extends DataModel.DataModel.AnyWithProps,\n  TableName extends DataModel.DataModel.TableNames<DataModel_>,\n  _TableInfo extends GenericTableInfo,\n  _TableInfo_ extends TableInfo.TableInfo.AnyWithProps,\n> = {\n  readonly get: {\n    (\n      id: GenericId<TableName>,\n    ): Effect.Effect<\n      _TableInfo_[\"document\"],\n      Document.DocumentDecodeError | GetByIdFailure\n    >;\n    <IndexName extends keyof Indexes<_TableInfo>>(\n      indexName: IndexName,\n      ...indexFieldValues: IndexFieldTypesForEq<\n        DataModel.DataModel.ToConvex<DataModel_>,\n        TableName,\n        Indexes<_TableInfo>[IndexName]\n      >\n    ): Effect.Effect<\n      _TableInfo_[\"document\"],\n      Document.DocumentDecodeError | GetByIndexFailure\n    >;\n  };\n  readonly index: {\n    <IndexName extends keyof Indexes<_TableInfo>>(\n      indexName: IndexName,\n      indexRange?: (\n        q: IndexRangeBuilder<\n          _TableInfo_[\"convexDocument\"],\n          NamedIndex<_TableInfo, IndexName>\n        >,\n      ) => IndexRange,\n      order?: \"asc\" | \"desc\",\n    ): OrderedQuery.OrderedQuery<_TableInfo_, TableName>;\n    <IndexName extends keyof Indexes<_TableInfo>>(\n      indexName: IndexName,\n      order?: \"asc\" | \"desc\",\n    ): OrderedQuery.OrderedQuery<_TableInfo_, TableName>;\n  };\n  readonly search: <IndexName extends keyof SearchIndexes<_TableInfo>>(\n    indexName: IndexName,\n    searchFilter: (\n      q: SearchFilterBuilder<\n        DocumentByInfo<_TableInfo>,\n        NamedSearchIndex<_TableInfo, IndexName>\n      >,\n    ) => SearchFilter,\n  ) => OrderedQuery.OrderedQuery<_TableInfo_, TableName>;\n};\n\nexport const make = <\n  Tables extends Table.Table.AnyWithProps,\n  TableName extends Table.Table.Name<Tables>,\n>(\n  tableName: TableName,\n  convexDatabaseReader: BaseDatabaseReader<\n    DataModel.DataModel.ToConvex<DataModel.DataModel.FromTables<Tables>>\n  >,\n  table: Table.Table.WithName<Tables, TableName>,\n): QueryInitializer<\n  DataModel.DataModel<Tables>,\n  TableName,\n  DataModel.DataModel.TableInfoWithName<DataModel.DataModel<Tables>, TableName>,\n  DataModel.DataModel.TableInfoWithName_<DataModel.DataModel<Tables>, TableName>\n> => {\n  type DataModel_ = DataModel.DataModel<Tables>;\n  type ConvexDataModel_ = DataModel.DataModel.ToConvex<DataModel_>;\n  type ThisQueryInitializer = QueryInitializer<\n    DataModel_,\n    TableName,\n    DataModel.DataModel.TableInfoWithName<DataModel_, TableName>,\n    DataModel.DataModel.TableInfoWithName_<DataModel_, TableName>\n  >;\n  type QueryInitializerFunction<\n    FunctionName extends keyof ThisQueryInitializer,\n  > = ThisQueryInitializer[FunctionName];\n\n  const getByIndex = <\n    IndexName extends keyof Indexes<\n      DataModel.DataModel.TableInfoWithName<DataModel_, TableName>\n    >,\n  >(\n    indexName: IndexName,\n    indexFieldValues: IndexFieldTypesForEq<\n      DataModel.DataModel.ToConvex<DataModel_>,\n      TableName,\n      Indexes<\n        DataModel.DataModel.TableInfoWithName<DataModel_, TableName>\n      >[IndexName]\n    >,\n  ): Effect.Effect<\n    DataModel.DataModel.DocumentWithName<DataModel_, TableName>,\n    Document.DocumentDecodeError | GetByIndexFailure\n  > => {\n    const indexFields: GenericTableIndexes[keyof GenericTableIndexes] = (\n      table.indexes as GenericTableIndexes\n    )[indexName as keyof GenericTableIndexes]!;\n\n    return pipe(\n      Effect.promise(() =>\n        convexDatabaseReader\n          .query(tableName)\n          .withIndex(indexName, (q) =>\n            Array.reduce(\n              indexFieldValues,\n              q,\n              (q_, v, i) => q_.eq(indexFields[i] as any, v as any) as any,\n            ),\n          )\n          .unique(),\n      ),\n      Effect.andThen(\n        Either.fromNullable(\n          () =>\n            new GetByIndexFailure({\n              tableName,\n              indexName: indexName as string,\n              indexFieldValues: indexFieldValues as string[],\n            }),\n        ),\n      ),\n      Effect.andThen(Document.decode(tableName, table.Fields)),\n    );\n  };\n\n  const get: QueryInitializerFunction<\"get\"> = ((\n    ...args: Parameters<QueryInitializerFunction<\"get\">>\n  ) => {\n    if (args.length === 1) {\n      const id = args[0] as GenericId<TableName>;\n\n      return getById(tableName, convexDatabaseReader, table)(id);\n    } else {\n      const [indexName, ...indexFieldValues] = args;\n\n      return getByIndex(\n        indexName as keyof Indexes<\n          DataModel.DataModel.TableInfoWithName<DataModel_, TableName>\n        >,\n        indexFieldValues,\n      );\n    }\n  }) as QueryInitializerFunction<\"get\">;\n\n  const index: QueryInitializerFunction<\"index\"> = <\n    IndexName extends keyof Indexes<\n      DataModel.DataModel.TableInfoWithName<DataModel_, TableName>\n    >,\n  >(\n    indexName: IndexName,\n    indexRangeOrOrder?:\n      | ((\n          q: IndexRangeBuilder<\n            DataModel.DataModel.TableInfoWithName_<\n              DataModel_,\n              TableName\n            >[\"convexDocument\"],\n            NamedIndex<\n              DataModel.DataModel.TableInfoWithName<DataModel_, TableName>,\n              IndexName\n            >\n          >,\n        ) => IndexRange)\n      | \"asc\"\n      | \"desc\",\n    order?: \"asc\" | \"desc\",\n  ) => {\n    const {\n      applyWithIndex,\n      applyOrder,\n    }: {\n      applyWithIndex: (\n        queryInitializer: ConvexQueryInitializer<\n          NamedTableInfo<ConvexDataModel_, TableName>\n        >,\n      ) => Query<NamedTableInfo<ConvexDataModel_, TableName>>;\n      applyOrder: (\n        query: Query<NamedTableInfo<ConvexDataModel_, TableName>>,\n      ) => ConvexOrderedQuery<NamedTableInfo<ConvexDataModel_, TableName>>;\n    } =\n      indexRangeOrOrder === undefined\n        ? {\n            applyWithIndex: (q) => q.withIndex(indexName),\n            applyOrder: (q) => q.order(\"asc\"),\n          }\n        : typeof indexRangeOrOrder === \"function\"\n          ? order === undefined\n            ? {\n                applyWithIndex: (q) =>\n                  q.withIndex(indexName, indexRangeOrOrder),\n                applyOrder: (q) => q.order(\"asc\"),\n              }\n            : {\n                applyWithIndex: (q) =>\n                  q.withIndex(indexName, indexRangeOrOrder),\n                applyOrder: (q) => q.order(order),\n              }\n          : {\n              applyWithIndex: (q) => q.withIndex(indexName),\n              applyOrder: (q) => q.order(indexRangeOrOrder),\n            };\n\n    const orderedQuery = pipe(\n      convexDatabaseReader.query(tableName),\n      applyWithIndex,\n      applyOrder,\n    );\n\n    return OrderedQuery.make<\n      DataModel.DataModel.TableInfoWithName_<DataModel_, TableName>,\n      TableName\n    >(orderedQuery, tableName, table.Fields);\n  };\n\n  const search: QueryInitializerFunction<\"search\"> = (\n    indexName,\n    searchFilter,\n  ) =>\n    OrderedQuery.make<\n      DataModel.DataModel.TableInfoWithName_<DataModel_, TableName>,\n      TableName\n    >(\n      convexDatabaseReader\n        .query(tableName)\n        .withSearchIndex(indexName, searchFilter),\n      tableName,\n      table.Fields,\n    );\n\n  return {\n    get,\n    index,\n    search,\n  };\n};\n\nexport const getById =\n  <\n    Tables extends Table.Table.AnyWithProps,\n    TableName extends Table.Table.Name<Tables>,\n  >(\n    tableName: TableName,\n    convexDatabaseReader: BaseDatabaseReader<\n      DataModel.DataModel.ToConvex<DataModel.DataModel.FromTables<Tables>>\n    >,\n    table: Table.Table.WithName<Tables, TableName>,\n  ) =>\n  (id: GenericId<TableName>) =>\n    pipe(\n      Effect.promise(() => convexDatabaseReader.get(id)),\n      Effect.andThen(\n        Either.fromNullable(() => new GetByIdFailure({ tableName, id })),\n      ),\n      Effect.andThen(Document.decode(tableName, table.Fields)),\n    );\n\nexport class GetByIdFailure extends Schema.TaggedError<GetByIdFailure>(\n  \"GetByIdFailure\",\n)(\"GetByIdFailure\", {\n  id: Schema.String,\n  tableName: Schema.String,\n}) {\n  override get message(): string {\n    return Document.documentErrorMessage({\n      id: this.id,\n      tableName: this.tableName,\n      message: \"not found\",\n    });\n  }\n}\n\nexport class GetByIndexFailure extends Schema.TaggedError<GetByIndexFailure>(\n  \"GetByIndexFailure\",\n)(\"GetByIndexFailure\", {\n  tableName: Schema.String,\n  indexName: Schema.String,\n  indexFieldValues: Schema.Array(Schema.String),\n}) {\n  override get message(): string {\n    return `No documents found in table '${this.tableName}' with index '${this.indexName}' and field values '${this.indexFieldValues}'`;\n  }\n}\n"],"mappings":";;;;;;;;;;;;AAiFA,MAAa,QAIX,WACA,sBAGA,UAMG;CAaH,MAAM,cAKJ,WACA,qBAUG;EACH,MAAMA,cACJ,MAAM,QACN;AAEF,SAAO,KACL,OAAO,cACL,qBACG,MAAM,UAAU,CAChB,UAAU,YAAY,MACrB,MAAM,OACJ,kBACA,IACC,IAAI,GAAG,MAAM,GAAG,GAAG,YAAY,IAAW,EAAS,CACrD,CACF,CACA,QAAQ,CACZ,EACD,OAAO,QACL,OAAO,mBAEH,IAAI,kBAAkB;GACpB;GACW;GACO;GACnB,CAAC,CACL,CACF,EACD,OAAO,QAAQC,OAAgB,WAAW,MAAM,OAAO,CAAC,CACzD;;CAGH,MAAMC,QACJ,GAAG,SACA;AACH,MAAI,KAAK,WAAW,GAAG;GACrB,MAAM,KAAK,KAAK;AAEhB,UAAO,QAAQ,WAAW,sBAAsB,MAAM,CAAC,GAAG;SACrD;GACL,MAAM,CAAC,WAAW,GAAG,oBAAoB;AAEzC,UAAO,WACL,WAGA,iBACD;;;CAIL,MAAMC,SAKJ,WACA,mBAeA,UACG;EACH,MAAM,EACJ,gBACA,eAWA,sBAAsB,SAClB;GACE,iBAAiB,MAAM,EAAE,UAAU,UAAU;GAC7C,aAAa,MAAM,EAAE,MAAM,MAAM;GAClC,GACD,OAAO,sBAAsB,aAC3B,UAAU,SACR;GACE,iBAAiB,MACf,EAAE,UAAU,WAAW,kBAAkB;GAC3C,aAAa,MAAM,EAAE,MAAM,MAAM;GAClC,GACD;GACE,iBAAiB,MACf,EAAE,UAAU,WAAW,kBAAkB;GAC3C,aAAa,MAAM,EAAE,MAAM,MAAM;GAClC,GACH;GACE,iBAAiB,MAAM,EAAE,UAAU,UAAU;GAC7C,aAAa,MAAM,EAAE,MAAM,kBAAkB;GAC9C;EAET,MAAM,eAAe,KACnB,qBAAqB,MAAM,UAAU,EACrC,gBACA,WACD;AAED,SAAOC,OAGL,cAAc,WAAW,MAAM,OAAO;;CAG1C,MAAMC,UACJ,WACA,iBAEAD,OAIE,qBACG,MAAM,UAAU,CAChB,gBAAgB,WAAW,aAAa,EAC3C,WACA,MAAM,OACP;AAEH,QAAO;EACL;EACA;EACA;EACD;;AAGH,MAAa,WAKT,WACA,sBAGA,WAED,OACC,KACE,OAAO,cAAc,qBAAqB,IAAI,GAAG,CAAC,EAClD,OAAO,QACL,OAAO,mBAAmB,IAAI,eAAe;CAAE;CAAW;CAAI,CAAC,CAAC,CACjE,EACD,OAAO,QAAQH,OAAgB,WAAW,MAAM,OAAO,CAAC,CACzD;AAEL,IAAa,iBAAb,cAAoC,OAAO,YACzC,iBACD,CAAC,kBAAkB;CAClB,IAAI,OAAO;CACX,WAAW,OAAO;CACnB,CAAC,CAAC;CACD,IAAa,UAAkB;AAC7B,SAAOK,qBAA8B;GACnC,IAAI,KAAK;GACT,WAAW,KAAK;GAChB,SAAS;GACV,CAAC;;;AAIN,IAAa,oBAAb,cAAuC,OAAO,YAC5C,oBACD,CAAC,qBAAqB;CACrB,WAAW,OAAO;CAClB,WAAW,OAAO;CAClB,kBAAkB,OAAO,MAAM,OAAO,OAAO;CAC9C,CAAC,CAAC;CACD,IAAa,UAAkB;AAC7B,SAAO,gCAAgC,KAAK,UAAU,gBAAgB,KAAK,UAAU,sBAAsB,KAAK,iBAAiB"}