{"version":3,"file":"SchemaToValidator.js","names":["GenericId.tableName","tableName"],"sources":["../../../src/server/SchemaToValidator.ts"],"sourcesContent":["import type {\n  OptionalProperty,\n  PropertyValidators,\n  Validator,\n  VAny,\n  VArray,\n  VBoolean,\n  VBytes,\n  VFloat64,\n  VId,\n  VInt64,\n  VLiteral,\n  VNull,\n  VObject,\n  VOptional,\n  VRecord,\n  VString,\n  VUnion,\n} from \"convex/values\";\nimport { v } from \"convex/values\";\nimport {\n  Array,\n  Cause,\n  Data,\n  Effect,\n  Exit,\n  Match,\n  Number,\n  Option,\n  type ParseResult,\n  pipe,\n  Predicate,\n  Schema,\n  SchemaAST,\n  String,\n} from \"effect\";\n\nimport * as GenericId from \"../api/GenericId\";\nimport type {\n  DeepMutable,\n  IsAny,\n  IsOptional,\n  IsRecordType,\n  IsRecursive,\n  IsUnion,\n  IsValueLiteral,\n  TypeError,\n  UnionToTuple,\n} from \"../internal/typeUtils\";\n\n// Args\n\nexport const compileArgsSchema = <ConfectValue, ConvexValue>(\n  argsSchema: Schema.Schema<ConfectValue, ConvexValue>,\n): PropertyValidators => {\n  const ast = Schema.encodedSchema(argsSchema).ast;\n\n  return pipe(\n    ast,\n    Match.value,\n    Match.tag(\"TypeLiteral\", (typeLiteralAst) =>\n      Array.isEmptyReadonlyArray(typeLiteralAst.indexSignatures)\n        ? handlePropertySignatures(typeLiteralAst)\n        : Effect.fail(new IndexSignaturesAreNotSupportedError()),\n    ),\n    Match.orElse(() => Effect.fail(new TopLevelMustBeObjectError())),\n    runSyncThrow,\n  );\n};\n\n// Returns\n\nexport const compileReturnsSchema = <ConfectValue, ConvexValue>(\n  schema: Schema.Schema<ConfectValue, ConvexValue>,\n): Validator<any, any, any> =>\n  runSyncThrow(compileAst(Schema.encodedSchema(schema).ast));\n\n// Table\n\n/**\n * Convert a table `Schema` to a table `Validator`.\n */\nexport type TableSchemaToTableValidator<\n  TableSchema extends Schema.Schema.AnyNoContext,\n> =\n  ValueToValidator<TableSchema[\"Encoded\"]> extends infer Vd extends\n    | VObject<any, any, any, any>\n    | VUnion<any, any, any, any>\n    ? Vd\n    : never;\n\nexport const compileTableSchema = <\n  TableSchema extends Schema.Schema.AnyNoContext,\n>(\n  schema: TableSchema,\n): TableSchemaToTableValidator<TableSchema> => {\n  const ast = Schema.encodedSchema(schema).ast;\n\n  return pipe(\n    ast,\n    Match.value,\n    Match.tag(\"TypeLiteral\", ({ indexSignatures }) =>\n      Array.isEmptyReadonlyArray(indexSignatures)\n        ? (compileAst(ast) as Effect.Effect<any>)\n        : Effect.fail(new IndexSignaturesAreNotSupportedError()),\n    ),\n    Match.tag(\"Union\", (unionAst) => compileAst(unionAst)),\n    Match.orElse(() => Effect.fail(new TopLevelMustBeObjectOrUnionError())),\n    runSyncThrow,\n  );\n};\n\n// Compiler\n\nexport type ReadonlyValue =\n  | string\n  | number\n  | bigint\n  | boolean\n  | ArrayBuffer\n  | ReadonlyArrayValue\n  | ReadonlyRecordValue\n  | null;\n\ntype ReadonlyArrayValue = readonly ReadonlyValue[];\n\nexport type ReadonlyRecordValue = {\n  readonly [key: string]: ReadonlyValue | undefined;\n};\n\nexport type ValueToValidator<Vl> =\n  IsRecursive<Vl> extends true\n    ? VAny\n    : [Vl] extends [never]\n      ? never\n      : IsAny<Vl> extends true\n        ? VAny\n        : [Vl] extends [ReadonlyValue]\n          ? Vl extends {\n              __tableName: infer TableName extends string;\n            }\n            ? VId<GenericId.GenericId<TableName>>\n            : IsValueLiteral<Vl> extends true\n              ? VLiteral<Vl>\n              : Vl extends null\n                ? VNull\n                : Vl extends number\n                  ? VFloat64\n                  : Vl extends bigint\n                    ? VInt64\n                    : Vl extends boolean\n                      ? VBoolean\n                      : Vl extends string\n                        ? VString\n                        : Vl extends ArrayBuffer\n                          ? VBytes\n                          : Vl extends ReadonlyArray<ReadonlyValue>\n                            ? ArrayValueToValidator<Vl>\n                            : Vl extends ReadonlyRecordValue\n                              ? RecordValueToValidator<Vl>\n                              : IsUnion<Vl> extends true\n                                ? UnionValueToValidator<Vl>\n                                : TypeError<\"Unexpected value\", Vl>\n          : TypeError<\"Provided value is not a valid Convex value\", Vl>;\n\ntype ArrayValueToValidator<Vl extends ReadonlyArray<ReadonlyValue>> =\n  Vl extends ReadonlyArray<infer El extends ReadonlyValue>\n    ? ValueToValidator<El> extends infer Vd extends Validator<any, any, any>\n      ? VArray<DeepMutable<El[]>, Vd>\n      : never\n    : never;\n\ntype RecordValueToValidator<Vl> = Vl extends ReadonlyRecordValue\n  ? {\n      -readonly [K in keyof Vl]-?: IsAny<Vl[K]> extends true\n        ? IsOptional<Vl, K> extends true\n          ? VOptional<VAny>\n          : VAny\n        : UndefinedOrValueToValidator<Vl[K]>;\n    } extends infer VdRecord extends Record<string, any>\n    ? {\n        -readonly [K in keyof Vl]: DeepMutable<Vl[K]>;\n      } extends infer VlRecord extends Record<string, any>\n      ? IsRecordType<VlRecord> extends true\n        ? VRecord<VlRecord, VString, VdRecord[keyof VdRecord]>\n        : VObject<VlRecord, VdRecord>\n      : never\n    : never\n  : never;\n\nexport type UndefinedOrValueToValidator<Vl extends ReadonlyValue | undefined> =\n  undefined extends Vl\n    ? [Vl] extends [(infer Val extends ReadonlyValue) | undefined]\n      ? ValueToValidator<Val> extends infer Vd extends Validator<\n          any,\n          OptionalProperty,\n          any\n        >\n        ? VOptional<Vd>\n        : never\n      : never\n    : Vl extends ReadonlyValue\n      ? ValueToValidator<Vl>\n      : never;\n\ntype UnionValueToValidator<Vl extends ReadonlyValue> = [Vl] extends [\n  ReadonlyValue,\n]\n  ? IsUnion<Vl> extends true\n    ? UnionToTuple<Vl> extends infer VlTuple extends\n        ReadonlyArray<ReadonlyValue>\n      ? ValueTupleToValidatorTuple<VlTuple> extends infer VdTuple extends\n          Validator<any, \"required\", any>[]\n        ? VUnion<DeepMutable<Vl>, VdTuple>\n        : TypeError<\"Failed to convert value tuple to validator tuple\">\n      : TypeError<\"Failed to convert union to tuple\">\n    : TypeError<\"Expected a union of values, but got a single value instead\">\n  : TypeError<\"Provided value is not a valid Convex value\">;\n\ntype ValueTupleToValidatorTuple<VlTuple extends ReadonlyArray<ReadonlyValue>> =\n  VlTuple extends\n    | [true, false, ...infer VlRest extends ReadonlyArray<ReadonlyValue>]\n    | [false, true, ...infer VlRest extends ReadonlyArray<ReadonlyValue>]\n    ? ValueTupleToValidatorTuple<VlRest> extends infer VdRest extends Validator<\n        any,\n        any,\n        any\n      >[]\n      ? [VBoolean<boolean>, ...VdRest]\n      : never\n    : VlTuple extends [\n          infer Vl extends ReadonlyValue,\n          ...infer VlRest extends ReadonlyArray<ReadonlyValue>,\n        ]\n      ? ValueToValidator<Vl> extends infer Vd extends Validator<any, any, any>\n        ? ValueTupleToValidatorTuple<VlRest> extends infer VdRest extends\n            Validator<any, \"required\", any>[]\n          ? [Vd, ...VdRest]\n          : never\n        : never\n      : [];\n\nexport const compileSchema = <T, E>(\n  schema: Schema.Schema<T, E>,\n): ValueToValidator<(typeof schema)[\"Encoded\"]> =>\n  runSyncThrow(compileAst(schema.ast)) as any;\n\nexport const isRecursive = (ast: SchemaAST.AST): boolean =>\n  pipe(\n    ast,\n    Match.value,\n    Match.tag(\n      \"Literal\",\n      \"BooleanKeyword\",\n      \"StringKeyword\",\n      \"NumberKeyword\",\n      \"BigIntKeyword\",\n      \"UnknownKeyword\",\n      \"AnyKeyword\",\n      \"Declaration\",\n      \"UniqueSymbol\",\n      \"SymbolKeyword\",\n      \"UndefinedKeyword\",\n      \"VoidKeyword\",\n      \"NeverKeyword\",\n      \"Enums\",\n      \"TemplateLiteral\",\n      \"ObjectKeyword\",\n      \"Transformation\",\n      () => false,\n    ),\n    Match.tag(\"Union\", ({ types }) =>\n      Array.some(types, (type) => isRecursive(type)),\n    ),\n    Match.tag(\"TypeLiteral\", ({ propertySignatures }) =>\n      Array.some(propertySignatures, ({ type }) => isRecursive(type)),\n    ),\n    Match.tag(\n      \"TupleType\",\n      ({ elements: optionalElements, rest: elements }) =>\n        Array.some(optionalElements, (optionalElement) =>\n          isRecursive(optionalElement.type),\n        ) || Array.some(elements, (element) => isRecursive(element.type)),\n    ),\n    Match.tag(\"Refinement\", ({ from }) => isRecursive(from)),\n    Match.tag(\"Suspend\", () => true),\n    Match.exhaustive,\n  );\n\nexport const compileAst = (\n  ast: SchemaAST.AST,\n  isOptionalPropertyOfTypeLiteral = false,\n): Effect.Effect<\n  Validator<any, any, any>,\n  | UnsupportedSchemaTypeError\n  | UnsupportedPropertySignatureKeyTypeError\n  | IndexSignaturesAreNotSupportedError\n  | MixedIndexAndPropertySignaturesAreNotSupportedError\n  | OptionalTupleElementsAreNotSupportedError\n  | EmptyTupleIsNotSupportedError\n> =>\n  isRecursive(ast)\n    ? Effect.succeed(v.any())\n    : pipe(\n        ast,\n        Match.value,\n        Match.tag(\"Literal\", ({ literal }) =>\n          pipe(\n            literal,\n            Match.value,\n            Match.whenOr(\n              Match.string,\n              Match.number,\n              Match.bigint,\n              Match.boolean,\n              (l) => v.literal(l),\n            ),\n            Match.when(Match.null, () => v.null()),\n            Match.exhaustive,\n            Effect.succeed,\n          ),\n        ),\n        Match.tag(\"BooleanKeyword\", () => Effect.succeed(v.boolean())),\n        Match.tag(\"StringKeyword\", (stringAst) =>\n          GenericId.tableName(stringAst).pipe(\n            Option.match({\n              onNone: () => Effect.succeed(v.string()),\n              onSome: (tableName) => Effect.succeed(v.id(tableName)),\n            }),\n          ),\n        ),\n        Match.tag(\"NumberKeyword\", () => Effect.succeed(v.float64())),\n        Match.tag(\"BigIntKeyword\", () => Effect.succeed(v.int64())),\n        Match.tag(\"Union\", (unionAst) =>\n          handleUnion(unionAst, isOptionalPropertyOfTypeLiteral),\n        ),\n        Match.tag(\"TypeLiteral\", (typeLiteralAst) =>\n          handleTypeLiteral(typeLiteralAst),\n        ),\n        Match.tag(\"TupleType\", (tupleTypeAst) => handleTupleType(tupleTypeAst)),\n        Match.tag(\"UnknownKeyword\", \"AnyKeyword\", () =>\n          Effect.succeed(v.any()),\n        ),\n        Match.tag(\"Declaration\", (declaration) =>\n          Effect.mapBoth(\n            declaration.decodeUnknown(...declaration.typeParameters)(\n              new ArrayBuffer(0),\n              {},\n              declaration,\n            ) as Effect.Effect<ArrayBuffer, ParseResult.ParseIssue>,\n            {\n              onSuccess: () => v.bytes(),\n              onFailure: () =>\n                new UnsupportedSchemaTypeError({\n                  schemaType: declaration._tag,\n                }),\n            },\n          ),\n        ),\n        Match.tag(\"Refinement\", ({ from }) => compileAst(from)),\n        Match.tag(\"Suspend\", () => Effect.succeed(v.any())),\n        Match.tag(\n          \"UniqueSymbol\",\n          \"SymbolKeyword\",\n          \"UndefinedKeyword\",\n          \"VoidKeyword\",\n          \"NeverKeyword\",\n          \"Enums\",\n          \"TemplateLiteral\",\n          \"ObjectKeyword\",\n          \"Transformation\",\n          () =>\n            new UnsupportedSchemaTypeError({\n              schemaType: ast._tag,\n            }),\n        ),\n        Match.exhaustive,\n      );\n\nconst handleUnion = (\n  { types: [first, second, ...rest] }: SchemaAST.Union,\n  isOptionalPropertyOfTypeLiteral: boolean,\n) =>\n  Effect.gen(function* () {\n    const validatorEffects = isOptionalPropertyOfTypeLiteral\n      ? Array.filterMap([first, second, ...rest], (type) =>\n          Predicate.not(SchemaAST.isUndefinedKeyword)(type)\n            ? Option.some(compileAst(type))\n            : Option.none(),\n        )\n      : Array.map([first, second, ...rest], (type) => compileAst(type));\n\n    const [firstValidator, secondValidator, ...restValidators] =\n      yield* Effect.all(validatorEffects);\n\n    /* v8 ignore start */\n    if (firstValidator === undefined) {\n      return yield* Effect.dieMessage(\n        \"First validator of union is undefined; this should be impossible.\",\n      );\n      /* v8 ignore stop */\n    } else if (secondValidator === undefined) {\n      return firstValidator;\n    } else {\n      return v.union(firstValidator, secondValidator, ...restValidators);\n    }\n  });\n\nconst handleTypeLiteral = (typeLiteralAst: SchemaAST.TypeLiteral) =>\n  pipe(\n    typeLiteralAst.indexSignatures,\n    Array.head,\n    Option.match({\n      onNone: () =>\n        Effect.map(handlePropertySignatures(typeLiteralAst), v.object),\n      onSome: ({ parameter, type }) =>\n        pipe(\n          typeLiteralAst.propertySignatures,\n          Array.head,\n          Option.match({\n            onNone: () =>\n              Effect.map(\n                Effect.all({\n                  parameter_: compileAst(parameter),\n                  type_: compileAst(type),\n                }),\n                ({ parameter_, type_ }) => v.record(parameter_, type_),\n              ),\n            onSome: () =>\n              Effect.fail(\n                new MixedIndexAndPropertySignaturesAreNotSupportedError(),\n              ),\n          }),\n        ),\n    }),\n  );\n\nconst handleTupleType = ({ elements, rest }: SchemaAST.TupleType) =>\n  Effect.gen(function* () {\n    const restValidator = pipe(\n      rest,\n      Array.head,\n      Option.map(({ type }) => compileAst(type)),\n      Effect.flatten,\n    );\n\n    const [f, s, ...r] = elements;\n\n    const elementToValidator = ({ type, isOptional }: SchemaAST.OptionalType) =>\n      Effect.if(isOptional, {\n        onTrue: () =>\n          Effect.fail(new OptionalTupleElementsAreNotSupportedError()),\n        onFalse: () => compileAst(type),\n      });\n\n    const arrayItemsValidator = yield* f === undefined\n      ? pipe(\n          restValidator,\n          Effect.catchTag(\"NoSuchElementException\", () =>\n            Effect.fail(new EmptyTupleIsNotSupportedError()),\n          ),\n        )\n      : s === undefined\n        ? elementToValidator(f)\n        : Effect.gen(function* () {\n            const firstValidator = yield* elementToValidator(f);\n            const secondValidator = yield* elementToValidator(s);\n            const restValidators = yield* Effect.forEach(r, elementToValidator);\n\n            return v.union(firstValidator, secondValidator, ...restValidators);\n          });\n\n    return v.array(arrayItemsValidator);\n  });\n\nconst handlePropertySignatures = (typeLiteralAst: SchemaAST.TypeLiteral) =>\n  pipe(\n    typeLiteralAst.propertySignatures,\n    Effect.forEach(({ type, name, isOptional }) => {\n      if (String.isString(name)) {\n        // Somehow, somewhere, keys of type number are being coerced to stringsâ€¦\n        return Option.match(Number.parse(name), {\n          onNone: () =>\n            Effect.gen(function* () {\n              const validator = yield* compileAst(type, isOptional);\n\n              return {\n                propertyName: name,\n                validator: isOptional ? v.optional(validator) : validator,\n              };\n            }),\n          onSome: (number) =>\n            Effect.fail(\n              new UnsupportedPropertySignatureKeyTypeError({\n                propertyKey: number,\n              }),\n            ),\n        });\n      } else {\n        return Effect.fail(\n          new UnsupportedPropertySignatureKeyTypeError({ propertyKey: name }),\n        );\n      }\n    }),\n    Effect.andThen((propertyNamesWithValidators) =>\n      pipe(\n        propertyNamesWithValidators,\n        Array.reduce(\n          {} as Record<string, Validator<any, any, any>>,\n          (acc, { propertyName, validator }) => ({\n            [propertyName]: validator,\n            ...acc,\n          }),\n        ),\n        Effect.succeed,\n      ),\n    ),\n  );\n\n// Errors\n\nconst runSyncThrow = <A, E>(effect: Effect.Effect<A, E>) =>\n  pipe(\n    effect,\n    Effect.runSyncExit,\n    Exit.match({\n      onSuccess: (validator) => validator,\n      onFailure: (cause) => {\n        throw Cause.squash(cause);\n      },\n    }),\n  );\n\nexport class TopLevelMustBeObjectError extends Data.TaggedError(\n  \"TopLevelMustBeObjectError\",\n) {\n  /* v8 ignore start */\n  override get message() {\n    return \"Top level schema must be an object\";\n  }\n  /* v8 ignore stop */\n}\n\nexport class TopLevelMustBeObjectOrUnionError extends Data.TaggedError(\n  \"TopLevelMustBeObjectOrUnionError\",\n) {\n  /* v8 ignore start */\n  override get message() {\n    return \"Top level schema must be an object or a union\";\n  }\n  /* v8 ignore stop */\n}\n\nexport class UnsupportedPropertySignatureKeyTypeError extends Data.TaggedError(\n  \"UnsupportedPropertySignatureKeyTypeError\",\n)<{\n  readonly propertyKey: number | symbol;\n}> {\n  /* v8 ignore start */\n  override get message() {\n    return `Unsupported property signature '${this.propertyKey.toString()}'. Property is of type '${typeof this.propertyKey}' but only 'string' properties are supported.`;\n  }\n  /* v8 ignore stop */\n}\n\nexport class EmptyTupleIsNotSupportedError extends Data.TaggedError(\n  \"EmptyTupleIsNotSupportedError\",\n) {\n  /* v8 ignore start */\n  override get message() {\n    return \"Tuple must have at least one element\";\n  }\n  /* v8 ignore stop */\n}\n\nexport class UnsupportedSchemaTypeError extends Data.TaggedError(\n  \"UnsupportedSchemaTypeError\",\n)<{\n  readonly schemaType: SchemaAST.AST[\"_tag\"];\n}> {\n  /* v8 ignore start */\n  override get message() {\n    return `Unsupported schema type '${this.schemaType}'`;\n  }\n  /* v8 ignore stop */\n}\n\nexport class IndexSignaturesAreNotSupportedError extends Data.TaggedError(\n  \"IndexSignaturesAreNotSupportedError\",\n) {\n  /* v8 ignore start */\n  override get message() {\n    return \"Index signatures are not supported\";\n  }\n  /* v8 ignore stop */\n}\n\nexport class MixedIndexAndPropertySignaturesAreNotSupportedError extends Data.TaggedError(\n  \"MixedIndexAndPropertySignaturesAreNotSupportedError\",\n) {\n  /* v8 ignore start */\n  override get message() {\n    return \"Mixed index and property signatures are not supported\";\n  }\n  /* v8 ignore stop */\n}\n\nexport class OptionalTupleElementsAreNotSupportedError extends Data.TaggedError(\n  \"OptionalTupleElementsAreNotSupportedError\",\n) {\n  /* v8 ignore start */\n  override get message() {\n    return \"Optional tuple elements are not supported\";\n  }\n  /* v8 ignore stop */\n}\n"],"mappings":"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"}