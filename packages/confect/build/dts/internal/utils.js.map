{"version":3,"file":"utils.js","names":["result: any","key"],"sources":["../../../src/internal/utils.ts"],"sourcesContent":["import type { Predicate } from \"effect\";\nimport { Array, Effect, Record } from \"effect\";\n\nconst RESERVED_KEYWORDS = new Set([\n  // Reserved keywords\n  \"break\",\n  \"case\",\n  \"catch\",\n  \"class\",\n  \"const\",\n  \"continue\",\n  \"debugger\",\n  \"default\",\n  \"delete\",\n  \"do\",\n  \"else\",\n  \"export\",\n  \"extends\",\n  \"finally\",\n  \"for\",\n  \"function\",\n  \"if\",\n  \"import\",\n  \"in\",\n  \"instanceof\",\n  \"new\",\n  \"return\",\n  \"super\",\n  \"switch\",\n  \"this\",\n  \"throw\",\n  \"try\",\n  \"typeof\",\n  \"var\",\n  \"void\",\n  \"while\",\n  \"with\",\n  \"yield\",\n  // Future reserved keywords\n  \"await\",\n  \"enum\",\n  \"implements\",\n  \"interface\",\n  \"let\",\n  \"package\",\n  \"private\",\n  \"protected\",\n  \"public\",\n  \"static\",\n  // Literal values that cannot be reassigned\n  \"null\",\n  \"true\",\n  \"false\",\n  // Global objects that shouldn't be shadowed\n  \"undefined\",\n]);\n\nconst jsIdentifierRegex = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/;\n\nconst matchesJsIdentifierPattern = (identifier: string) =>\n  jsIdentifierRegex.test(identifier);\n\nconst isReservedKeyword = (identifier: string) =>\n  RESERVED_KEYWORDS.has(identifier);\n\nexport const validateJsIdentifier = (identifier: string) => {\n  if (!matchesJsIdentifierPattern(identifier)) {\n    throw new Error(\n      `Expected a valid JavaScript identifier, but received: \"${identifier}\". Valid identifiers must start with a letter, underscore, or dollar sign, and can only contain letters, numbers, underscores, or dollar signs.`,\n    );\n  }\n\n  if (isReservedKeyword(identifier)) {\n    throw new Error(\n      `Expected a valid JavaScript identifier, but received: \"${identifier}\". \"${identifier}\" is a reserved keyword.`,\n    );\n  }\n};\n\ntype NestedObject<T> = {\n  [key: string]: T | NestedObject<T>;\n};\n\nexport const mapLeaves = <T, U>(\n  obj: NestedObject<T>,\n  leafRefinement: Predicate.Refinement<unknown, T>,\n  f: (value: T) => U,\n): NestedObject<U> => {\n  const result: any = {};\n\n  for (const key in obj) {\n    const value = obj[key];\n\n    if (leafRefinement(value)) {\n      result[key] = f(value as T);\n    } else {\n      result[key] = mapLeaves(value as NestedObject<T>, leafRefinement, f);\n    }\n  }\n\n  return result;\n};\n\nconst collectBranchLeaves = <T>(\n  obj: NestedObject<T>,\n  leafRefinement: Predicate.Refinement<unknown, T>,\n  path: string[] = [],\n): { path: string[]; values: Record<string, T> }[] => {\n  const leaves = Record.filter(obj, leafRefinement) as Record<string, T>;\n  const hasLeaves = Record.keys(leaves).length > 0;\n\n  const currentBranch = hasLeaves ? [{ path, values: leaves }] : [];\n\n  const nestedBranches = Array.flatMap(Record.keys(obj), (key) => {\n    const value = obj[key];\n\n    if (!leafRefinement(value) && typeof value === \"object\") {\n      return collectBranchLeaves(value as NestedObject<T>, leafRefinement, [\n        ...path,\n        key,\n      ]);\n    }\n    return [];\n  });\n\n  return [...currentBranch, ...nestedBranches];\n};\n\nexport const forEachBranchLeaves = <T, A, E, R>(\n  obj: NestedObject<T>,\n  leafRefinement: Predicate.Refinement<unknown, T>,\n  f: (branchLeaves: {\n    path: string[];\n    values: Record<string, T>;\n  }) => Effect.Effect<A, E, R>,\n): Effect.Effect<void, E, R> => {\n  const branchLeaves = collectBranchLeaves(obj, leafRefinement);\n  return Effect.forEach(branchLeaves, f, {\n    discard: true,\n  });\n};\n\nexport const setNestedProperty = <T extends object>(\n  obj: T,\n  path: PropertyKey[],\n  value: any,\n): T => {\n  if (path.length === 0) {\n    return obj;\n  }\n\n  if (path.length === 1) {\n    const key = path[0] as keyof T;\n    return { ...obj, [key]: value };\n  }\n\n  const [head, ...tail] = path;\n  const key = head as keyof T;\n  return {\n    ...obj,\n    [key]: setNestedProperty((obj as any)[key] ?? {}, tail, value),\n  };\n};\n"],"mappings":";;;AAGA,MAAM,oBAAoB,IAAI,IAAI;CAEhC;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CAEA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CAEA;CACA;CACA;CAEA;CACD,CAAC;AAEF,MAAM,oBAAoB;AAE1B,MAAM,8BAA8B,eAClC,kBAAkB,KAAK,WAAW;AAEpC,MAAM,qBAAqB,eACzB,kBAAkB,IAAI,WAAW;AAEnC,MAAa,wBAAwB,eAAuB;AAC1D,KAAI,CAAC,2BAA2B,WAAW,CACzC,OAAM,IAAI,MACR,0DAA0D,WAAW,iJACtE;AAGH,KAAI,kBAAkB,WAAW,CAC/B,OAAM,IAAI,MACR,0DAA0D,WAAW,MAAM,WAAW,0BACvF;;AAQL,MAAa,aACX,KACA,gBACA,MACoB;CACpB,MAAMA,SAAc,EAAE;AAEtB,MAAK,MAAM,OAAO,KAAK;EACrB,MAAM,QAAQ,IAAI;AAElB,MAAI,eAAe,MAAM,CACvB,QAAO,OAAO,EAAE,MAAW;MAE3B,QAAO,OAAO,UAAU,OAA0B,gBAAgB,EAAE;;AAIxE,QAAO;;AAGT,MAAM,uBACJ,KACA,gBACA,OAAiB,EAAE,KACiC;CACpD,MAAM,SAAS,OAAO,OAAO,KAAK,eAAe;CAGjD,MAAM,gBAFY,OAAO,KAAK,OAAO,CAAC,SAAS,IAEb,CAAC;EAAE;EAAM,QAAQ;EAAQ,CAAC,GAAG,EAAE;CAEjE,MAAM,iBAAiB,MAAM,QAAQ,OAAO,KAAK,IAAI,GAAG,QAAQ;EAC9D,MAAM,QAAQ,IAAI;AAElB,MAAI,CAAC,eAAe,MAAM,IAAI,OAAO,UAAU,SAC7C,QAAO,oBAAoB,OAA0B,gBAAgB,CACnE,GAAG,MACH,IACD,CAAC;AAEJ,SAAO,EAAE;GACT;AAEF,QAAO,CAAC,GAAG,eAAe,GAAG,eAAe;;AAG9C,MAAa,uBACX,KACA,gBACA,MAI8B;CAC9B,MAAM,eAAe,oBAAoB,KAAK,eAAe;AAC7D,QAAO,OAAO,QAAQ,cAAc,GAAG,EACrC,SAAS,MACV,CAAC;;AAGJ,MAAa,qBACX,KACA,MACA,UACM;AACN,KAAI,KAAK,WAAW,EAClB,QAAO;AAGT,KAAI,KAAK,WAAW,GAAG;EACrB,MAAMC,QAAM,KAAK;AACjB,SAAO;GAAE,GAAG;IAAMA,QAAM;GAAO;;CAGjC,MAAM,CAAC,MAAM,GAAG,QAAQ;CACxB,MAAM,MAAM;AACZ,QAAO;EACL,GAAG;GACF,MAAM,kBAAmB,IAAY,QAAQ,EAAE,EAAE,MAAM,MAAM;EAC/D"}